import "std/sequences.pile"
import "std/io.pile"

def W 10 end
def H 10 end

proc RenderGrid let grid
	0 loop dup H = if break end
		0 loop dup W = if break end
			as y x let
			
			y W * x + let idx
			grid idx @ ~ if " . " else " # " end
			STDOUT swap write

			y x
			1 +
		end drop
		STDOUT "\n" write
		1 +
	end drop
end

proc GetCoordinate as x y width let
	y width * x +
end

proc CountNbors as
	grid
	width
	height
	x
	y
let
	y 1 - dup 0 <       if drop height 1 -  end let up
	y 1 + dup height >= if drop 0           end let down
	x 1 - dup 0 <       if drop width 1 -   end let left
	x 1 + dup width >=  if drop 0           end let right

	0
	grid right y    width GetCoordinate @ if 1 + end
	grid left  y    width GetCoordinate @ if 1 + end
	grid x     up   width GetCoordinate @ if 1 + end
	grid x     down width GetCoordinate @ if 1 + end
	grid right down width GetCoordinate @ if 1 + end
	grid left  down width GetCoordinate @ if 1 + end
	grid right up   width GetCoordinate @ if 1 + end
	grid left  up   width GetCoordinate @ if 1 + end
end

proc Tick as base target width height let
	0 loop dup height = if break end
		0 loop dup width = if break end
			as y x let
			
			x y width GetCoordinate let cell
			base width height x y CountNbors let nbors
			
			base cell @ if
				nbors 2 < if false end
				nbors 2 = nbors 3 = | if true end
				nbors 3 > if false end
			else false nbors 3 = if ~ end end
				let state
			
			target cell state !

			y x
			1 +
		end drop
		1 +
	end drop
end

proc Main
	array false W H * Repeat end let grid1
	array false W H * Repeat end let grid2
	
	# Glider
	grid1 2 2 W GetCoordinate true !
	grid1 3 3 W GetCoordinate true !
	grid1 3 4 W GetCoordinate true !
	grid1 2 4 W GetCoordinate true !
	grid1 1 4 W GetCoordinate true !

	loop
		# Tick
		grid1 grid2 W H Tick

		# Invert buffers
		grid1 let temp
		grid2 let grid1
		temp let grid2

		# Render next generation
		grid1 RenderGrid

		Input drop
	end
end
Main
