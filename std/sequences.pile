# Executes a range starting from `a` to `b` by step `s`
# ( a b s -- ... )
proc range
    let step
    loop over over >= if break end
        over
        step +
        swap
    end
    drop drop
end

# Pushes `x` by `n` times on the stack 
# ( x n -- x x .. n )
proc repeat
    loop dup 0 = if break end
        over
        swap
        1 -
    end
    drop drop
end

# Pushes each item of array `a` directly on the stack
# ( a -- a[0] a[1] ... )
proc unwrap
    let arr
    0 loop dup arr len = if break end
        arr over @
        swap
        1 +
    end drop
end

# Pushes a reversed version of array `a1` on the stack
# ( a1 -- a2 )
proc reversed
    dup len 1 + let max
    array
        0 loop dup max = if break end
            over over 0 swap - @
            rot rot
            1 +
        end
        drop drop
    end
end

# Copies an array recursively and returns the copied array
# ( a1 -- a2 )
proc copy
    let a1
    array
        0 loop dup a1 len = if break end
            a1 over @ let item
            item typeof "array" = if
                item cpy
            else
                item
            end
            swap
            1 +
        end drop
    end
end

# Traverses the array `a` linearly and searches for `q`.
# If the query is found, it lets the index on the stack. Otherwise, nil.
# ( a q -- i )
proc find as a q let
    nil let found
    a len let l
    0 loop dup l >= if break end
        a over @ q = if
            dup let found
            break
        end
        1 +
    end drop
    found
end
